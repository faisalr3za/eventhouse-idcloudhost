const express = require('express');
const { body, param, validationResult } = require('express-validator');
const paymentService = require('../services/paymentService');
const { TenantModel, TenantUserModel } = require('../models');
const { requireTenant } = require('../middleware/tenantResolver');
const { authenticate } = require('../middleware/auth');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * @swagger
 * /api/payment/subscription:
 *   post:
 *     summary: Create subscription payment
 *     tags: [Payment]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - planId
 *               - provider
 *               - customerData
 *             properties:
 *               planId:
 *                 type: integer
 *                 description: Subscription plan ID
 *               provider:
 *                 type: string
 *                 enum: [midtrans, xendit]
 *                 description: Payment provider
 *               billingPeriod:
 *                 type: string
 *                 enum: [monthly, yearly]
 *                 default: monthly
 *               customerData:
 *                 type: object
 *                 required:
 *                   - firstName
 *                   - lastName
 *                   - email
 *                   - phone
 *                 properties:
 *                   firstName:
 *                     type: string
 *                   lastName:
 *                     type: string
 *                   email:
 *                     type: string
 *                     format: email
 *                   phone:
 *                     type: string
 *                   address:
 *                     type: string
 *                   city:
 *                     type: string
 *                   postalCode:
 *                     type: string
 *     responses:
 *       200:
 *         description: Payment link created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 data:
 *                   type: object
 *                   properties:
 *                     provider:
 *                       type: string
 *                     orderId:
 *                       type: string
 *                     paymentUrl:
 *                       type: string
 *                     paymentToken:
 *                       type: string
 *                     expiresAt:
 *                       type: string
 *                       format: date-time
 */\nrouter.post('/subscription', [\n    requireTenant,\n    authenticate,\n    body('planId').isInt({ min: 1 }).withMessage('Valid plan ID is required'),\n    body('provider').isIn(['midtrans', 'xendit']).withMessage('Provider must be midtrans or xendit'),\n    body('billingPeriod').optional().isIn(['monthly', 'yearly']).withMessage('Billing period must be monthly or yearly'),\n    body('customerData.firstName').notEmpty().withMessage('First name is required'),\n    body('customerData.lastName').notEmpty().withMessage('Last name is required'),\n    body('customerData.email').isEmail().withMessage('Valid email is required'),\n    body('customerData.phone').notEmpty().withMessage('Phone number is required')\n], async (req, res) => {\n    try {\n        const errors = validationResult(req);\n        if (!errors.isEmpty()) {\n            return res.status(400).json({\n                success: false,\n                message: 'Validation failed',\n                errors: errors.array()\n            });\n        }\n\n        const { planId, provider, billingPeriod = 'monthly', customerData } = req.body;\n        const { tenant, user } = req;\n\n        // Get subscription plan details\n        const plan = await db.query(\n            'SELECT * FROM subscription_plans WHERE id = $1 AND is_active = true',\n            [planId]\n        );\n\n        if (!plan.rows[0]) {\n            return res.status(404).json({\n                success: false,\n                message: 'Subscription plan not found'\n            });\n        }\n\n        const planData = plan.rows[0];\n        let amount = planData.price;\n\n        // Apply yearly discount if applicable\n        if (billingPeriod === 'yearly') {\n            amount = amount * 12 * 0.8; // 20% discount for yearly\n        }\n\n        // Convert USD to IDR if needed\n        if (planData.currency === 'USD' && (provider === 'midtrans' || provider === 'xendit')) {\n            const usdToIdr = 15000; // This should be fetched from exchange rate API\n            amount = amount * usdToIdr;\n        }\n\n        const subscriptionData = {\n            tenantId: tenant.id,\n            planId: planData.id,\n            planName: planData.name,\n            amount,\n            currency: 'IDR',\n            customerData,\n            billingPeriod\n        };\n\n        const paymentResult = await paymentService.createSubscriptionPayment(subscriptionData, provider);\n\n        // Store payment record in database\n        await db.query(`\n            INSERT INTO payment_transactions (tenant_id, order_id, plan_id, amount, currency, \n                                             provider, status, billing_period, customer_data, \n                                             payment_token, expires_at, created_by)\n            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\n        `, [\n            tenant.id,\n            paymentResult.orderId,\n            planId,\n            amount,\n            'IDR',\n            provider,\n            'pending',\n            billingPeriod,\n            JSON.stringify(customerData),\n            paymentResult.paymentToken,\n            paymentResult.expiresAt,\n            user.id\n        ]);\n\n        logger.info('Subscription payment created:', {\n            tenantId: tenant.id,\n            orderId: paymentResult.orderId,\n            planId,\n            provider,\n            amount\n        });\n\n        res.json({\n            success: true,\n            message: 'Payment link created successfully',\n            data: {\n                provider: paymentResult.provider,\n                orderId: paymentResult.orderId,\n                paymentUrl: paymentResult.paymentUrl,\n                paymentToken: paymentResult.paymentToken,\n                expiresAt: paymentResult.expiresAt,\n                amount: paymentService.formatCurrency(amount),\n                planName: planData.name,\n                billingPeriod\n            }\n        });\n\n    } catch (error) {\n        logger.error('Error creating subscription payment:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to create payment link',\n            error: process.env.NODE_ENV === 'development' ? error.message : undefined\n        });\n    }\n});\n\n/**\n * @swagger\n * /api/payment/webhook/midtrans:\n *   post:\n *     summary: Handle Midtrans webhook\n *     tags: [Payment]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *     responses:\n *       200:\n *         description: Webhook processed successfully\n */\nrouter.post('/webhook/midtrans', async (req, res) => {\n    try {\n        const notification = req.body;\n        \n        logger.info('Midtrans webhook received:', notification);\n        \n        const paymentResult = await paymentService.handleMidtransWebhook(notification);\n        \n        // Update payment status in database\n        await updatePaymentStatus(paymentResult);\n        \n        res.status(200).json({ status: 'OK' });\n        \n    } catch (error) {\n        logger.error('Error handling Midtrans webhook:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n/**\n * @swagger\n * /api/payment/webhook/xendit:\n *   post:\n *     summary: Handle Xendit webhook\n *     tags: [Payment]\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *     responses:\n *       200:\n *         description: Webhook processed successfully\n */\nrouter.post('/webhook/xendit', async (req, res) => {\n    try {\n        const webhookData = req.body;\n        const signature = req.headers['x-callback-token'];\n        \n        logger.info('Xendit webhook received:', webhookData);\n        \n        const paymentResult = await paymentService.handleXenditWebhook(webhookData, signature);\n        \n        // Update payment status in database\n        await updatePaymentStatus(paymentResult);\n        \n        res.status(200).json({ status: 'OK' });\n        \n    } catch (error) {\n        logger.error('Error handling Xendit webhook:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n/**\n * @swagger\n * /api/payment/status/{orderId}:\n *   get:\n *     summary: Get payment status\n *     tags: [Payment]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: orderId\n *         required: true\n *         schema:\n *           type: string\n *         description: Payment order ID\n *       - in: query\n *         name: provider\n *         required: true\n *         schema:\n *           type: string\n *           enum: [midtrans, xendit]\n *         description: Payment provider\n *     responses:\n *       200:\n *         description: Payment status retrieved successfully\n */\nrouter.get('/status/:orderId', [\n    requireTenant,\n    authenticate,\n    param('orderId').notEmpty().withMessage('Order ID is required')\n], async (req, res) => {\n    try {\n        const errors = validationResult(req);\n        if (!errors.isEmpty()) {\n            return res.status(400).json({\n                success: false,\n                errors: errors.array()\n            });\n        }\n\n        const { orderId } = req.params;\n        const { provider } = req.query;\n        const { tenant } = req;\n\n        if (!provider || !['midtrans', 'xendit'].includes(provider)) {\n            return res.status(400).json({\n                success: false,\n                message: 'Valid provider (midtrans or xendit) is required'\n            });\n        }\n\n        // Check if payment belongs to tenant\n        const payment = await db.query(\n            'SELECT * FROM payment_transactions WHERE order_id = $1 AND tenant_id = $2',\n            [orderId, tenant.id]\n        );\n\n        if (!payment.rows[0]) {\n            return res.status(404).json({\n                success: false,\n                message: 'Payment not found'\n            });\n        }\n\n        const paymentStatus = await paymentService.getPaymentStatus(orderId, provider);\n\n        res.json({\n            success: true,\n            data: {\n                orderId: paymentStatus.orderId,\n                status: paymentStatus.status,\n                amount: paymentService.formatCurrency(paymentStatus.amount),\n                provider: paymentStatus.provider,\n                updatedAt: new Date().toISOString()\n            }\n        });\n\n    } catch (error) {\n        logger.error('Error getting payment status:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to get payment status',\n            error: process.env.NODE_ENV === 'development' ? error.message : undefined\n        });\n    }\n});\n\n/**\n * @swagger\n * /api/payment/methods:\n *   get:\n *     summary: Get available payment methods\n *     tags: [Payment]\n *     parameters:\n *       - in: query\n *         name: provider\n *         required: true\n *         schema:\n *           type: string\n *           enum: [midtrans, xendit]\n *     responses:\n *       200:\n *         description: Payment methods retrieved successfully\n */\nrouter.get('/methods', (req, res) => {\n    try {\n        const { provider } = req.query;\n\n        if (!provider || !['midtrans', 'xendit'].includes(provider)) {\n            return res.status(400).json({\n                success: false,\n                message: 'Valid provider (midtrans or xendit) is required'\n            });\n        }\n\n        const methods = paymentService.getAvailablePaymentMethods(provider);\n\n        res.json({\n            success: true,\n            data: {\n                provider,\n                methods\n            }\n        });\n\n    } catch (error) {\n        logger.error('Error getting payment methods:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to get payment methods'\n        });\n    }\n});\n\n/**\n * @swagger\n * /api/payment/cancel/{orderId}:\n *   post:\n *     summary: Cancel payment\n *     tags: [Payment]\n *     security:\n *       - bearerAuth: []\n *     parameters:\n *       - in: path\n *         name: orderId\n *         required: true\n *         schema:\n *           type: string\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - provider\n *             properties:\n *               provider:\n *                 type: string\n *                 enum: [midtrans, xendit]\n *     responses:\n *       200:\n *         description: Payment cancelled successfully\n */\nrouter.post('/cancel/:orderId', [\n    requireTenant,\n    authenticate,\n    param('orderId').notEmpty().withMessage('Order ID is required'),\n    body('provider').isIn(['midtrans', 'xendit']).withMessage('Provider must be midtrans or xendit')\n], async (req, res) => {\n    try {\n        const errors = validationResult(req);\n        if (!errors.isEmpty()) {\n            return res.status(400).json({\n                success: false,\n                errors: errors.array()\n            });\n        }\n\n        const { orderId } = req.params;\n        const { provider } = req.body;\n        const { tenant, user } = req;\n\n        // Check if payment belongs to tenant\n        const payment = await db.query(\n            'SELECT * FROM payment_transactions WHERE order_id = $1 AND tenant_id = $2',\n            [orderId, tenant.id]\n        );\n\n        if (!payment.rows[0]) {\n            return res.status(404).json({\n                success: false,\n                message: 'Payment not found'\n            });\n        }\n\n        if (payment.rows[0].status !== 'pending') {\n            return res.status(400).json({\n                success: false,\n                message: 'Only pending payments can be cancelled'\n            });\n        }\n\n        await paymentService.cancelPayment(orderId, provider);\n\n        // Update payment status in database\n        await db.query(\n            'UPDATE payment_transactions SET status = $1, updated_at = CURRENT_TIMESTAMP WHERE order_id = $2',\n            ['cancelled', orderId]\n        );\n\n        logger.info('Payment cancelled:', {\n            orderId,\n            tenantId: tenant.id,\n            userId: user.id,\n            provider\n        });\n\n        res.json({\n            success: true,\n            message: 'Payment cancelled successfully'\n        });\n\n    } catch (error) {\n        logger.error('Error cancelling payment:', error);\n        res.status(500).json({\n            success: false,\n            message: 'Failed to cancel payment',\n            error: process.env.NODE_ENV === 'development' ? error.message : undefined\n        });\n    }\n});\n\n// Helper function to update payment status\nasync function updatePaymentStatus(paymentResult) {\n    try {\n        const {\n            orderId,\n            status,\n            amount,\n            tenantId,\n            planId,\n            billingPeriod,\n            provider,\n            rawData\n        } = paymentResult;\n\n        // Update payment transaction\n        await db.query(`\n            UPDATE payment_transactions \n            SET status = $1, updated_at = CURRENT_TIMESTAMP, raw_response = $2\n            WHERE order_id = $3\n        `, [status, JSON.stringify(rawData), orderId]);\n\n        // If payment is successful, update tenant subscription\n        if (status === 'success') {\n            const currentDate = new Date();\n            let endsAt;\n\n            if (billingPeriod === 'yearly') {\n                endsAt = new Date(currentDate.getFullYear() + 1, currentDate.getMonth(), currentDate.getDate());\n            } else {\n                endsAt = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, currentDate.getDate());\n            }\n\n            // Update or create subscription\n            await db.query(`\n                INSERT INTO tenant_subscriptions (tenant_id, plan_id, status, starts_at, ends_at, \n                                                 billing_email, metadata)\n                VALUES ($1, $2, 'active', CURRENT_TIMESTAMP, $3, \n                        (SELECT customer_data->>'email' FROM payment_transactions WHERE order_id = $4),\n                        $5)\n                ON CONFLICT (tenant_id) \n                DO UPDATE SET \n                    plan_id = EXCLUDED.plan_id,\n                    status = EXCLUDED.status,\n                    starts_at = EXCLUDED.starts_at,\n                    ends_at = EXCLUDED.ends_at,\n                    updated_at = CURRENT_TIMESTAMP\n            `, [tenantId, planId, endsAt, orderId, JSON.stringify({ provider, orderId, billingPeriod })]);\n\n            logger.info('Subscription activated:', {\n                tenantId,\n                planId,\n                orderId,\n                endsAt\n            });\n        }\n\n    } catch (error) {\n        logger.error('Error updating payment status:', error);\n        throw error;\n    }\n}\n\nmodule.exports = router;"
